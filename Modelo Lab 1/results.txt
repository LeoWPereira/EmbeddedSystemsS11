teste5x5.pgm

-O0 				: 611
-O1 				: 578 (-5,40%)
-O2 				: 553 (-9,49%)
-Ofast 				: 530 (-13,26%)
w/o size constrains	: 568  (-7,00%)


lena512pgm

-O0 				: 12249731
-O1 				: 11985551 (-2,16%)
-O2 				: 11463823 (-6,41%)
-Ofast 				: 11718821 (-4,33%)
w/o size constrains	: 8811307  (-28,07%)





						Divide by 3

Convert to binary. 1 / 3 = 00111110 10101010 10101010 10101011

Left shift until there is a 1 to the right of the binary point. 
	In this case it requires 2 shifts and we get 0.11111010 10101010 10101010 10101111. S is thus 2.

Take the most significant 17 bits: 1111 1010 1010 1010 1

Add 1: giving 1111 1010 1010 1010 1 + 1 = 	1111 1010 1010 1011 0

Truncate to 16 bits: 1111 1010 1010 1011

Express in hexadecimal: M = 0xFAAB

Q = (((uint32_t)A * (uint32_t)0xFAAB) >> 16) >> 2

An exhaustive check confirms that this expression does indeed do the job for all 16 bit values of A. 
It is also about 10 times faster than the compiler division routine on an AVR processor.